mps_arena_tranform_objects -- testing


__What needs to be tested__

Verification:
  - existing refs to news are unchanged;
  - all managed refs to olds are transformed: heap walk finds none;
  - rest of object graph is unchanged (except for collecing garbage, weakness, etc).

Where are the refs?
  - Ambig roots:
    + stack;
    + declared;
  - Exact roots
  - in objects:
    + young, old;
    + condemned (co-seg-resident with olds) or not;
    + which pool class;
    + which pool.
  - in Exact objects rank-promoted by barrier hit and scanned at Ambig?
  - Weak refs.
  - in Weak objects rank-promoted by barrier hit and scanned at Exact?
  - Finalization guardians.
    
  - (0.1 interface)
    + in old list, or not.

Where are the objects?
  - which pool class
  - which pool
  - condemned (co-seg-resident with olds) or not;

What is happening when the transform is requested?
  - arena is already parked;
  - released but no trace in progress;
  - incremental minor trace in progress;
  - incremental full trace in progress.

What happens during the trace?
  - no problems;
  - ambiguous refs found, transform aborted;
  - ControlPool full;
  - other emergency, check PoolFixEmergency is called.

Funny transforms:
  - million olds all mapping to one new;
  - NULL olds;
  - NULL news;
  - identity entries (old == new).

Illegal transforms:
  - non-idempotent;
  - duplicate entries of the same old ref in old_list;
  - olds that are not a GCSeg.

Reporting the results:
  - error code;
  - transform_done_o Bool is allocated by the client:
    + on stack;
    + static;
    + in managed object.
    + in old object?!


__How the test code will work__

Test:
make a graph
turn it into two numbers:
  Number 1 is used to verify that the transform did not break anything.
  Number 2 is used to verify that the transform did actually change something!
choose some olds, make new copies, and transform the graph
verify that number_1 is the same, report old and new number_2s

How to get the two numbers:
  n1(main-root):
    for i in main-root
      n1 += i * n1(tree at main[i])
  n1(tree):
    n1 = 13*node + 17*left + 19*right
  n2(main-root):
    for i in main-root
      n2 += n2(tree at main[i])
  n2(tree):
    n2 = node + left + right


$Id$